{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useRoutes = exports.getWorkingPath = exports.usePath = exports.getPath = exports.setPath = exports.navigate = exports.ParentContext = exports.getBasepath = exports.setBasepath = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _isNode = _interopRequireDefault(require(\"./isNode\"));\n\nvar _queryParams = require(\"./queryParams\");\n\nvar _interceptor = require(\"./interceptor\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nvar preparedRoutes = {};\nvar stack = {};\nvar componentId = 1;\nvar currentPath = _isNode.default ? '' : location.pathname;\nvar basePath = '';\nvar basePathRegEx = null;\nvar pathUpdaters = [];\n/**\r\n * Will define a base path that will be utilized in your routing and navigation.\r\n * To be called _before_ any routing or navigation happens.\r\n * @param {string} inBasepath\r\n */\n\nvar setBasepath = function setBasepath(inBasepath) {\n  basePath = inBasepath;\n  basePathRegEx = new RegExp('^' + basePath);\n};\n/**\r\n * Returns the currently used base path.\r\n * @returns {string}\r\n */\n\n\nexports.setBasepath = setBasepath;\n\nvar getBasepath = function getBasepath() {\n  return basePath;\n};\n\nexports.getBasepath = getBasepath;\n\nvar resolvePath = function resolvePath(inPath) {\n  if (_isNode.default) {\n    var url = require('url');\n\n    return url.resolve(currentPath, inPath);\n  }\n\n  var current = new URL(currentPath, location.href);\n  var resolved = new URL(inPath, current);\n  return resolved.pathname;\n};\n\nvar ParentContext = _react.default.createContext(null);\n/**\r\n * Pass a route string to this function to receive a regular expression.\r\n * The transformation will be cached and if you pass the same route a second\r\n * time, the cached regex will be returned.\r\n * @param {string} inRoute\r\n * @returns {Array} [RegExp, propList]\r\n */\n\n\nexports.ParentContext = ParentContext;\n\nvar prepareRoute = function prepareRoute(inRoute) {\n  if (preparedRoutes[inRoute]) {\n    return preparedRoutes[inRoute];\n  }\n\n  var preparedRoute = [new RegExp(\"\".concat(inRoute.substr(0, 1) === '*' ? '' : '^').concat(inRoute.replace(/:[a-zA-Z]+/g, '([^/]+)').replace(/\\*/g, '')).concat(inRoute.substr(-1) === '*' ? '' : '$'))];\n  var propList = inRoute.match(/:[a-zA-Z]+/g);\n  preparedRoute.push(propList ? propList.map(function (paramName) {\n    return paramName.substr(1);\n  }) : []);\n  preparedRoutes[inRoute] = preparedRoute;\n  return preparedRoute;\n};\n/**\r\n * Virtually navigates the browser to the given URL and re-processes all routers.\r\n * @param {string} url The URL to navigate to. Do not mix adding GET params here and using the `getParams` argument.\r\n * @param {boolean} [replace=false] Should the navigation be done with a history replace to prevent back navigation by the user\r\n * @param {object} [queryParams] Key/Value pairs to convert into get parameters to be appended to the URL.\r\n * @param {boolean} [replaceQueryParams=true] Should existing query parameters be carried over, or dropped (replaced)?\r\n */\n\n\nvar navigate = function navigate(url) {\n  var replace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var queryParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var replaceQueryParams = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  url = (0, _interceptor.interceptRoute)(currentPath, resolvePath(url));\n\n  if (!url || url === currentPath) {\n    return;\n  }\n\n  currentPath = url;\n\n  if (_isNode.default) {\n    setPath(url);\n    processStack();\n    updatePathHooks();\n    return;\n  }\n\n  var finalURL = basePathRegEx ? url.match(basePathRegEx) ? url : basePath + url : url;\n  window.history[\"\".concat(replace ? 'replace' : 'push', \"State\")](null, null, finalURL);\n  processStack();\n  updatePathHooks();\n\n  if (queryParams) {\n    (0, _queryParams.setQueryParams)(queryParams, replaceQueryParams);\n  }\n};\n\nexports.navigate = navigate;\nvar customPath = '/';\n/**\r\n * Enables you to manually set the path from outside in a nodeJS environment, where window.history is not available.\r\n * @param {string} inPath\r\n */\n\nvar setPath = function setPath(inPath) {\n  var url = require('url');\n\n  customPath = url.resolve(customPath, inPath);\n};\n/**\r\n * Returns the current path of the router.\r\n * @returns {string}\r\n */\n\n\nexports.setPath = setPath;\n\nvar getPath = function getPath() {\n  return customPath;\n};\n/**\r\n * This hook returns the currently used URI.\r\n * Works in a browser context as well as for SSR.\r\n *\r\n * _Heads up:_ This will make your component render on every navigation unless you set this hook to passive!\r\n * @param {boolean} [active=true] Will update the component upon path changes. Set to false to only retrieve the path, once.\r\n * @param {boolean} [withBasepath=false] Should the base path be left at the beginning of the URI?\r\n * @returns {string}\r\n */\n\n\nexports.getPath = getPath;\n\nvar usePath = function usePath() {\n  var active = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  var withBasepath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var _React$useState = _react.default.useState(0),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      setUpdate = _React$useState2[1];\n\n  _react.default.useEffect(function () {\n    if (!active) {\n      return;\n    }\n\n    pathUpdaters.push(setUpdate);\n    return function () {\n      var index = pathUpdaters.indexOf(setUpdate);\n\n      if (index !== -1) {\n        pathUpdaters.splice(index, 1);\n      }\n    };\n  }, [setUpdate]);\n\n  return withBasepath ? currentPath : currentPath.replace(basePathRegEx, '');\n};\n/**\r\n * Render all components that use path hooks.\r\n */\n\n\nexports.usePath = usePath;\n\nvar updatePathHooks = function updatePathHooks() {\n  var now = Date.now();\n  pathUpdaters.forEach(function (cb) {\n    return cb(now);\n  });\n};\n/**\r\n * Called from within the router. This returns either the current windows url path\r\n * or a already reduced path, if a parent router has already matched with a finishing\r\n * wildcard before.\r\n * @param {string} [parentRouterId]\r\n * @returns {string}\r\n */\n\n\nvar getWorkingPath = function getWorkingPath(parentRouterId) {\n  if (!parentRouterId) {\n    return _isNode.default ? customPath : window.location.pathname.replace(basePathRegEx, '') || '/';\n  }\n\n  var stackEntry = stack[parentRouterId];\n\n  if (!stackEntry) {\n    throw 'wth';\n  }\n\n  return stackEntry.reducedPath !== null ? stackEntry.reducedPath || '/' : window.location.pathname;\n};\n\nexports.getWorkingPath = getWorkingPath;\n\nvar processStack = function processStack() {\n  return Object.values(stack).forEach(process);\n};\n/**\r\n * This function takes two objects and compares if they have the same\r\n * keys and their keys have the same values assigned, so the objects are\r\n * basically the same.\r\n * @param {object} objA\r\n * @param {object} objB\r\n * @return {boolean}\r\n */\n\n\nvar objectsEqual = function objectsEqual(objA, objB) {\n  var objAKeys = Object.keys(objA);\n  var objBKeys = Object.keys(objB);\n\n  var valueIsEqual = function valueIsEqual(key) {\n    return objB.hasOwnProperty(key) && objA[key] === objB[key];\n  };\n\n  return objAKeys.length === objBKeys.length && objAKeys.every(valueIsEqual);\n};\n\nif (!_isNode.default) {\n  window.addEventListener('popstate', function (e) {\n    var nextPath = (0, _interceptor.interceptRoute)(currentPath, location.pathname);\n\n    if (!nextPath || nextPath === currentPath) {\n      e.preventDefault();\n      e.stopPropagation();\n      history.pushState(null, null, currentPath);\n      return;\n    }\n\n    currentPath = nextPath;\n\n    if (nextPath !== location.pathname) {\n      history.replaceState(null, null, nextPath);\n    }\n\n    processStack();\n    updatePathHooks();\n  });\n}\n\nvar emptyFunc = function emptyFunc() {\n  return null;\n};\n/**\r\n * This will calculate the match of a given router.\r\n * @param {object} stackObj\r\n * @param {boolean} [directCall] If its not a direct call, the process function might trigger a component render.\r\n */\n\n\nvar process = function process(stackObj, directCall) {\n  var routerId = stackObj.routerId,\n      parentRouterId = stackObj.parentRouterId,\n      routes = stackObj.routes,\n      setUpdate = stackObj.setUpdate,\n      resultFunc = stackObj.resultFunc,\n      resultProps = stackObj.resultProps,\n      previousReducedPath = stackObj.reducedPath;\n  var currentPath = getWorkingPath(parentRouterId);\n  var route = null;\n  var targetFunction = null;\n  var targetProps = null;\n  var reducedPath = null;\n  var anyMatched = false;\n\n  for (var i = 0; i < routes.length; i++) {\n    var _routes$i = _slicedToArray(routes[i], 2);\n\n    route = _routes$i[0];\n    targetFunction = _routes$i[1];\n\n    var _ref = preparedRoutes[route] ? preparedRoutes[route] : prepareRoute(route),\n        _ref2 = _slicedToArray(_ref, 2),\n        regex = _ref2[0],\n        groupNames = _ref2[1];\n\n    var _result = currentPath.match(regex);\n\n    if (!_result) {\n      targetFunction = emptyFunc;\n      continue;\n    }\n\n    if (groupNames.length) {\n      targetProps = {};\n\n      for (var j = 0; j < groupNames.length; j++) {\n        targetProps[groupNames[j]] = _result[j + 1];\n      }\n    }\n\n    reducedPath = currentPath.replace(_result[0], '');\n    anyMatched = true;\n    break;\n  }\n\n  if (!stack[routerId]) {\n    return;\n  }\n\n  if (!anyMatched) {\n    route = null;\n    targetFunction = null;\n    targetProps = null;\n    reducedPath = null;\n  }\n\n  var funcsDiffer = resultFunc !== targetFunction;\n  var pathDiffer = reducedPath !== previousReducedPath;\n  var propsDiffer = true;\n\n  if (!funcsDiffer) {\n    if (!resultProps && !targetProps) {\n      propsDiffer = false;\n    } else {\n      propsDiffer = !(resultProps && targetProps && objectsEqual(resultProps, targetProps) === true);\n    }\n\n    if (!propsDiffer) {\n      if (!pathDiffer) {\n        return;\n      }\n    }\n  }\n\n  var result = funcsDiffer || propsDiffer ? targetFunction ? targetFunction(targetProps) : null : stackObj.result;\n  Object.assign(stack[routerId], {\n    result: result,\n    reducedPath: reducedPath,\n    matchedRoute: route,\n    passContext: route ? route.substr(-1) === '*' : false\n  });\n\n  if (!directCall && (funcsDiffer || propsDiffer || route === null)) {\n    setUpdate(Date.now());\n  }\n};\n/**\r\n * If a route returns a function, instead of a react element, we need to wrap this function\r\n * to eventually wrap a context object around its result.\r\n * @param RouteContext\r\n * @param originalResult\r\n * @returns {function(): *}\r\n */\n\n\nvar wrapperFunction = function wrapperFunction(RouteContext, originalResult) {\n  return function () {\n    return _react.default.createElement(RouteContext, null, originalResult.apply(originalResult, arguments));\n  };\n};\n/**\r\n * Pass an object to this function where the keys are routes and the values\r\n * are functions to be executed when a route matches. Whatever your function returns\r\n * will be returned from the hook as well into your react component. Ideally you would\r\n * return components to be rendered when certain routes match, but you are not limited\r\n * to that.\r\n * @param {object} routeObj {\"/someRoute\": () => <Example />}\r\n */\n\n\nvar useRoutes = function useRoutes(routeObj) {\n  // Each router gets an internal id to look them up again.\n  var _React$useState3 = _react.default.useState(componentId),\n      _React$useState4 = _slicedToArray(_React$useState3, 1),\n      routerId = _React$useState4[0];\n\n  var setUpdate = _react.default.useState(0)[1]; // Needed to create nested routers which use only a subset of the URL.\n\n\n  var parentRouterId = _react.default.useContext(ParentContext); // If we just took the last ID, increase it for the next hook.\n\n\n  if (routerId === componentId) {\n    componentId += 1;\n  } // Removes the router from the stack after component unmount - it won't be processed anymore.\n\n\n  _react.default.useEffect(function () {\n    return function () {\n      return delete stack[routerId];\n    };\n  }, [routerId]);\n\n  var stackObj = stack[routerId];\n\n  if (stackObj && stackObj.originalRouteObj !== routeObj) {\n    stackObj = null;\n  }\n\n  if (!stackObj) {\n    stackObj = {\n      routerId: routerId,\n      originalRouteObj: routeObj,\n      routes: Object.entries(routeObj),\n      setUpdate: setUpdate,\n      parentRouterId: parentRouterId,\n      matchedRoute: null,\n      reducedPath: null,\n      passContext: false,\n      result: null\n    };\n    stack[routerId] = stackObj;\n    process(stackObj, true);\n  }\n\n  _react.default.useDebugValue(stackObj.matchedRoute);\n\n  if (!stackObj.matchedRoute) {\n    return null;\n  }\n\n  var result = stackObj.result;\n\n  if (!stackObj.passContext) {\n    return result;\n  } else {\n    var RouteContext = function RouteContext(_ref3) {\n      var children = _ref3.children;\n      return _react.default.createElement(ParentContext.Provider, {\n        value: routerId\n      }, children);\n    };\n\n    if (typeof result === 'function') {\n      return wrapperFunction(RouteContext, result);\n    }\n\n    return _react.default.isValidElement(result) && result.type !== RouteContext ? _react.default.createElement(RouteContext, null, result) : result;\n  }\n};\n\nexports.useRoutes = useRoutes;","map":{"version":3,"mappings":"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","names":["preparedRoutes","stack","componentId","currentPath","isNode","location","pathname","basePath","basePathRegEx","pathUpdaters","setBasepath","inBasepath","RegExp","getBasepath","resolvePath","inPath","url","require","resolve","current","URL","href","resolved","ParentContext","React","createContext","prepareRoute","inRoute","preparedRoute","substr","replace","propList","match","push","map","paramName","navigate","queryParams","replaceQueryParams","setPath","processStack","updatePathHooks","finalURL","window","history","customPath","getPath","usePath","active","withBasepath","useState","setUpdate","useEffect","index","indexOf","splice","now","Date","forEach","cb","getWorkingPath","parentRouterId","stackEntry","reducedPath","Object","values","process","objectsEqual","objA","objB","objAKeys","keys","objBKeys","valueIsEqual","hasOwnProperty","key","length","every","addEventListener","e","nextPath","preventDefault","stopPropagation","pushState","replaceState","emptyFunc","stackObj","directCall","routerId","routes","resultFunc","resultProps","previousReducedPath","route","targetFunction","targetProps","anyMatched","i","regex","groupNames","result","j","funcsDiffer","pathDiffer","propsDiffer","assign","matchedRoute","passContext","wrapperFunction","RouteContext","originalResult","_react","apply","arguments","useRoutes","routeObj","useContext","originalRouteObj","entries","useDebugValue","children","Provider","value","isValidElement","type"],"sources":["/home/daksh/Projects/Trivia_Game/frontend/node_modules/hookrouter/src/router.js"],"sourcesContent":["import React from 'react';\r\nimport isNode from './isNode';\r\nimport {setQueryParams} from './queryParams';\r\nimport {interceptRoute} from './interceptor';\r\n\r\nlet preparedRoutes = {};\r\nlet stack = {};\r\nlet componentId = 1;\r\nlet currentPath = isNode ? '' : location.pathname;\r\nlet basePath = '';\r\nlet basePathRegEx = null;\r\nconst pathUpdaters = [];\r\n\r\n/**\r\n * Will define a base path that will be utilized in your routing and navigation.\r\n * To be called _before_ any routing or navigation happens.\r\n * @param {string} inBasepath\r\n */\r\nexport const setBasepath = (inBasepath) => {\r\n\tbasePath = inBasepath;\r\n\tbasePathRegEx = new RegExp('^' + basePath);\r\n};\r\n\r\n/**\r\n * Returns the currently used base path.\r\n * @returns {string}\r\n */\r\nexport const getBasepath = () => basePath;\r\n\r\nconst resolvePath = (inPath) => {\r\n\tif (isNode) {\r\n\t\tconst url = require('url');\r\n\t\treturn url.resolve(currentPath, inPath);\r\n\t}\r\n\r\n\tconst current = new URL(currentPath, location.href);\r\n\tconst resolved = new URL(inPath, current);\r\n\treturn resolved.pathname;\r\n};\r\n\r\nexport const ParentContext = React.createContext(null);\r\n\r\n/**\r\n * Pass a route string to this function to receive a regular expression.\r\n * The transformation will be cached and if you pass the same route a second\r\n * time, the cached regex will be returned.\r\n * @param {string} inRoute\r\n * @returns {Array} [RegExp, propList]\r\n */\r\nconst prepareRoute = (inRoute) => {\r\n\tif (preparedRoutes[inRoute]) {\r\n\t\treturn preparedRoutes[inRoute];\r\n\t}\r\n\r\n\tconst preparedRoute = [\r\n\t\tnew RegExp(`${inRoute.substr(0, 1) === '*' ? '' : '^'}${inRoute.replace(/:[a-zA-Z]+/g, '([^/]+)').replace(/\\*/g, '')}${inRoute.substr(-1,) === '*' ? '' : '$'}`)\r\n\t];\r\n\r\n\tconst propList = inRoute.match(/:[a-zA-Z]+/g);\r\n\tpreparedRoute.push(\r\n\t\tpropList\r\n\t\t\t? propList.map(paramName => paramName.substr(1))\r\n\t\t\t: []\r\n\t);\r\n\r\n\tpreparedRoutes[inRoute] = preparedRoute;\r\n\treturn preparedRoute;\r\n};\r\n\r\n/**\r\n * Virtually navigates the browser to the given URL and re-processes all routers.\r\n * @param {string} url The URL to navigate to. Do not mix adding GET params here and using the `getParams` argument.\r\n * @param {boolean} [replace=false] Should the navigation be done with a history replace to prevent back navigation by the user\r\n * @param {object} [queryParams] Key/Value pairs to convert into get parameters to be appended to the URL.\r\n * @param {boolean} [replaceQueryParams=true] Should existing query parameters be carried over, or dropped (replaced)?\r\n */\r\nexport const navigate = (url, replace = false, queryParams = null, replaceQueryParams = true) => {\r\n\turl = interceptRoute(currentPath, resolvePath(url));\r\n\r\n\tif (!url || url === currentPath) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tcurrentPath = url;\r\n\r\n\tif (isNode) {\r\n\t\tsetPath(url);\r\n\t\tprocessStack();\r\n\t\tupdatePathHooks();\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst finalURL = basePathRegEx\r\n\t\t? url.match(basePathRegEx)\r\n\t\t\t? url\r\n\t\t\t: basePath + url\r\n\t\t:\r\n\t\turl;\r\n\r\n\twindow.history[`${replace ? 'replace' : 'push'}State`](null, null, finalURL);\r\n\tprocessStack();\r\n\tupdatePathHooks();\r\n\r\n\tif (queryParams) {\r\n\t\tsetQueryParams(queryParams, replaceQueryParams);\r\n\t}\r\n};\r\n\r\nlet customPath = '/';\r\n/**\r\n * Enables you to manually set the path from outside in a nodeJS environment, where window.history is not available.\r\n * @param {string} inPath\r\n */\r\nexport const setPath = (inPath) => {\r\n\tconst url = require('url');\r\n\tcustomPath = url.resolve(customPath, inPath);\r\n};\r\n\r\n/**\r\n * Returns the current path of the router.\r\n * @returns {string}\r\n */\r\nexport const getPath = () => customPath;\r\n\r\n/**\r\n * This hook returns the currently used URI.\r\n * Works in a browser context as well as for SSR.\r\n *\r\n * _Heads up:_ This will make your component render on every navigation unless you set this hook to passive!\r\n * @param {boolean} [active=true] Will update the component upon path changes. Set to false to only retrieve the path, once.\r\n * @param {boolean} [withBasepath=false] Should the base path be left at the beginning of the URI?\r\n * @returns {string}\r\n */\r\nexport const usePath = (active = true, withBasepath = false) => {\r\n\tconst [, setUpdate] = React.useState(0);\r\n\r\n\tReact.useEffect(() => {\r\n\t\tif (!active) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tpathUpdaters.push(setUpdate);\r\n\t\treturn () => {\r\n\t\t\tconst index = pathUpdaters.indexOf(setUpdate);\r\n\t\t\tif (index !== -1) {\r\n\t\t\t\tpathUpdaters.splice(index, 1);\r\n\t\t\t}\r\n\t\t};\r\n\t}, [setUpdate]);\r\n\r\n\treturn withBasepath ? currentPath : currentPath.replace(basePathRegEx, '');\r\n};\r\n\r\n/**\r\n * Render all components that use path hooks.\r\n */\r\nconst updatePathHooks = () => {\r\n\tconst now = Date.now();\r\n\tpathUpdaters.forEach(cb => cb(now));\r\n};\r\n\r\n/**\r\n * Called from within the router. This returns either the current windows url path\r\n * or a already reduced path, if a parent router has already matched with a finishing\r\n * wildcard before.\r\n * @param {string} [parentRouterId]\r\n * @returns {string}\r\n */\r\nexport const getWorkingPath = (parentRouterId) => {\r\n\tif (!parentRouterId) {\r\n\t\treturn isNode ? customPath : window.location.pathname.replace(basePathRegEx, '') || '/';\r\n\t}\r\n\tconst stackEntry = stack[parentRouterId];\r\n\tif (!stackEntry) {\r\n\t\tthrow 'wth';\r\n\t}\r\n\r\n\treturn stackEntry.reducedPath !== null ? stackEntry.reducedPath || '/' : window.location.pathname;\r\n};\r\n\r\nconst processStack = () => Object.values(stack).forEach(process);\r\n\r\n/**\r\n * This function takes two objects and compares if they have the same\r\n * keys and their keys have the same values assigned, so the objects are\r\n * basically the same.\r\n * @param {object} objA\r\n * @param {object} objB\r\n * @return {boolean}\r\n */\r\nconst objectsEqual = (objA, objB) => {\r\n\tconst objAKeys = Object.keys(objA);\r\n\tconst objBKeys = Object.keys(objB);\r\n\r\n\tconst valueIsEqual = key => objB.hasOwnProperty(key) && objA[key] === objB[key];\r\n\r\n\treturn (\r\n\t\tobjAKeys.length === objBKeys.length\r\n\t\t&& objAKeys.every(valueIsEqual)\r\n\t);\r\n};\r\n\r\nif (!isNode) {\r\n\twindow.addEventListener('popstate', (e) => {\r\n\t\tconst nextPath = interceptRoute(currentPath, location.pathname);\r\n\r\n\t\tif (!nextPath || nextPath === currentPath) {\r\n\t\t\te.preventDefault();\r\n\t\t\te.stopPropagation();\r\n\t\t\thistory.pushState(null, null, currentPath);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tcurrentPath = nextPath;\r\n\r\n\t\tif (nextPath !== location.pathname) {\r\n\t\t\thistory.replaceState(null, null, nextPath);\r\n\t\t}\r\n\t\tprocessStack();\r\n\t\tupdatePathHooks();\r\n\t});\r\n}\r\n\r\nconst emptyFunc = () => null;\r\n\r\n/**\r\n * This will calculate the match of a given router.\r\n * @param {object} stackObj\r\n * @param {boolean} [directCall] If its not a direct call, the process function might trigger a component render.\r\n */\r\nconst process = (stackObj, directCall) => {\r\n\tconst {\r\n\t\trouterId,\r\n\t\tparentRouterId,\r\n\t\troutes,\r\n\t\tsetUpdate,\r\n\t\tresultFunc,\r\n\t\tresultProps,\r\n\t\treducedPath: previousReducedPath\r\n\t} = stackObj;\r\n\r\n\tconst currentPath = getWorkingPath(parentRouterId);\r\n\tlet route = null;\r\n\tlet targetFunction = null;\r\n\tlet targetProps = null;\r\n\tlet reducedPath = null;\r\n\tlet anyMatched = false;\r\n\r\n\tfor (let i = 0; i < routes.length; i++) {\r\n\t\t[route, targetFunction] = routes[i];\r\n\t\tconst [regex, groupNames] = preparedRoutes[route]\r\n\t\t\t? preparedRoutes[route]\r\n\t\t\t: prepareRoute(route);\r\n\r\n\t\tconst result = currentPath.match(regex);\r\n\t\tif (!result) {\r\n\t\t\ttargetFunction = emptyFunc;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (groupNames.length) {\r\n\t\t\ttargetProps = {};\r\n\t\t\tfor (let j = 0; j < groupNames.length; j++) {\r\n\t\t\t\ttargetProps[groupNames[j]] = result[j + 1];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treducedPath = currentPath.replace(result[0], '');\r\n\t\tanyMatched = true;\r\n\t\tbreak;\r\n\t}\r\n\r\n\tif (!stack[routerId]) {\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!anyMatched) {\r\n\t\troute = null;\r\n\t\ttargetFunction = null;\r\n\t\ttargetProps = null;\r\n\t\treducedPath = null;\r\n\t}\r\n\r\n\tconst funcsDiffer = resultFunc !== targetFunction;\r\n\tconst pathDiffer = reducedPath !== previousReducedPath;\r\n\tlet propsDiffer = true;\r\n\r\n\tif (!funcsDiffer) {\r\n\t\tif (!resultProps && !targetProps) {\r\n\t\t\tpropsDiffer = false;\r\n\t\t} else {\r\n\t\t\tpropsDiffer = !(resultProps && targetProps && objectsEqual(resultProps, targetProps) === true);\r\n\t\t}\r\n\r\n\t\tif (!propsDiffer) {\r\n\t\t\tif (!pathDiffer) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tconst result = funcsDiffer || propsDiffer\r\n\t\t? targetFunction\r\n\t\t\t? targetFunction(targetProps)\r\n\t\t\t: null\r\n\t\t: stackObj.result;\r\n\r\n\tObject.assign(stack[routerId], {\r\n\t\tresult,\r\n\t\treducedPath,\r\n\t\tmatchedRoute: route,\r\n\t\tpassContext: route ? route.substr(-1) === '*' : false\r\n\t});\r\n\r\n\tif (!directCall && (funcsDiffer || propsDiffer || route === null)) {\r\n\t\tsetUpdate(Date.now());\r\n\t}\r\n};\r\n\r\n/**\r\n * If a route returns a function, instead of a react element, we need to wrap this function\r\n * to eventually wrap a context object around its result.\r\n * @param RouteContext\r\n * @param originalResult\r\n * @returns {function(): *}\r\n */\r\nconst wrapperFunction = (RouteContext, originalResult) => function (){\r\n\treturn (\r\n\t\t<RouteContext>{originalResult.apply(originalResult, arguments)}</RouteContext>\r\n\t);\r\n};\r\n\r\n/**\r\n * Pass an object to this function where the keys are routes and the values\r\n * are functions to be executed when a route matches. Whatever your function returns\r\n * will be returned from the hook as well into your react component. Ideally you would\r\n * return components to be rendered when certain routes match, but you are not limited\r\n * to that.\r\n * @param {object} routeObj {\"/someRoute\": () => <Example />}\r\n */\r\nexport const useRoutes = (routeObj) => {\r\n\t// Each router gets an internal id to look them up again.\r\n\tconst [routerId] = React.useState(componentId);\r\n\tconst setUpdate = React.useState(0)[1];\r\n\t// Needed to create nested routers which use only a subset of the URL.\r\n\tconst parentRouterId = React.useContext(ParentContext);\r\n\r\n\t// If we just took the last ID, increase it for the next hook.\r\n\tif (routerId === componentId) {\r\n\t\tcomponentId += 1;\r\n\t}\r\n\r\n\t// Removes the router from the stack after component unmount - it won't be processed anymore.\r\n\tReact.useEffect(() => () => delete stack[routerId], [routerId]);\r\n\r\n\tlet stackObj = stack[routerId];\r\n\r\n\tif (stackObj && stackObj.originalRouteObj !== routeObj) {\r\n\t\tstackObj = null;\r\n\t}\r\n\r\n\tif (!stackObj) {\r\n\t\tstackObj = {\r\n\t\t\trouterId,\r\n\t\t\toriginalRouteObj: routeObj,\r\n\t\t\troutes: Object.entries(routeObj),\r\n\t\t\tsetUpdate,\r\n\t\t\tparentRouterId,\r\n\t\t\tmatchedRoute: null,\r\n\t\t\treducedPath: null,\r\n\t\t\tpassContext: false,\r\n\t\t\tresult: null\r\n\t\t};\r\n\r\n\t\tstack[routerId] = stackObj;\r\n\r\n\t\tprocess(stackObj, true);\r\n\t}\r\n\r\n\tReact.useDebugValue(stackObj.matchedRoute);\r\n\r\n\tif (!stackObj.matchedRoute) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tlet result = stackObj.result;\r\n\r\n\tif (!stackObj.passContext) {\r\n\t\treturn result;\r\n\t} else {\r\n\t\tconst RouteContext = ({children}) => <ParentContext.Provider value={routerId}>{children}</ParentContext.Provider>;\r\n\r\n\t\tif (typeof result === 'function') {\r\n\t\t\treturn wrapperFunction(RouteContext, result);\r\n\t\t}\r\n\r\n\t\treturn React.isValidElement(result) && result.type !== RouteContext\r\n\t\t\t? <RouteContext>{result}</RouteContext>\r\n\t\t\t: result;\r\n\t}\r\n};\r\n"]},"metadata":{},"sourceType":"script"}