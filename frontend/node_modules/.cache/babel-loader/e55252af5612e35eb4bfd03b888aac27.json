{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useControlledInterceptor = void 0;\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _interceptor = require(\"./interceptor\");\n\nvar _router = require(\"./router\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/**\r\n * This is a controlled version of the interceptor which cancels any navigation intent\r\n * and hands control over it to your calling component.\r\n *\r\n * `interceptedPath` is initially `null` and will be set to the target path upon navigation.\r\n * `confirmNavigation` is the callback to be called to stop the interception and navigate to the last path.\r\n * `resetPath` is a callback that resets `interceptedPath` back to `null`.\r\n *\r\n * @returns {Array} [interceptedPath, confirmNavigation, resetPath]\r\n */\n\n\nvar useControlledInterceptor = function useControlledInterceptor() {\n  var _React$useState = _react.default.useState(null),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      interceptedPath = _React$useState2[0],\n      setInterceptedPath = _React$useState2[1];\n\n  var interceptorFunction = _react.default.useMemo(function () {\n    return function (currentPath, nextPath) {\n      setInterceptedPath(nextPath);\n      return currentPath;\n    };\n  }, [setInterceptedPath]);\n\n  var stopInterception = (0, _interceptor.useInterceptor)(interceptorFunction);\n\n  var confirmNavigation = _react.default.useMemo(function () {\n    return function () {\n      stopInterception();\n      (0, _router.navigate)(interceptedPath);\n    };\n  }, [stopInterception, interceptedPath]);\n\n  var resetPath = _react.default.useMemo(function () {\n    return function () {\n      return setInterceptedPath(null);\n    };\n  }, [setInterceptedPath]);\n\n  return [interceptedPath, confirmNavigation, resetPath, stopInterception];\n};\n\nexports.useControlledInterceptor = useControlledInterceptor;","map":{"version":3,"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;AAUO,IAAMA,wBAAwB,GAAG,SAA3BA,wBAA2B,GAAM;AAAA,wBACCC,eAAMC,QAAND,CAAe,IAAfA,CADD;AAAA;AAAA,MACtCE,eADsC;AAAA,MACrBC,kBADqB;;AAG7C,MAAMC,mBAAmB,GAAGJ,eAAMK,OAANL,CAC3B;AAAA,WAAM,UAACM,WAAD,EAAcC,QAAd,EAA2B;AAChCJ,wBAAkB,CAACI,QAAD,CAAlBJ;AACA,aAAOG,WAAP;AAFD;AAD2B,KAK3B,CAACH,kBAAD,CAL2BH,CAA5B;;AAQA,MAAMQ,gBAAgB,GAAG,iCAAeJ,mBAAf,CAAzB;;AAEA,MAAMK,iBAAiB,GAAGT,eAAMK,OAANL,CACzB;AAAA,WAAM,YAAM;AACXQ,sBAAgB;AAChB,4BAASN,eAAT;AAFD;AADyB,KAKzB,CAACM,gBAAD,EAAmBN,eAAnB,CALyBF,CAA1B;;AAQA,MAAMU,SAAS,GAAGV,eAAMK,OAANL,CACjB;AAAA,WAAM;AAAA,aAAMG,kBAAkB,CAAC,IAAD,CAAxB;AAAN;AADiB,KAEjB,CAACA,kBAAD,CAFiBH,CAAlB;;AAKA,SAAO,CAACE,eAAD,EAAkBO,iBAAlB,EAAqCC,SAArC,EAAgDF,gBAAhD,CAAP;AA1BM","names":["useControlledInterceptor","React","useState","interceptedPath","setInterceptedPath","interceptorFunction","useMemo","currentPath","nextPath","stopInterception","confirmNavigation","resetPath"],"sources":["/home/daksh/Projects/Trivia_Game/frontend/node_modules/hookrouter/src/controlledInterceptor.js"],"sourcesContent":["import React from 'react';\r\nimport {useInterceptor} from \"./interceptor\";\r\nimport {navigate} from \"./router\";\r\n\r\n/**\r\n * This is a controlled version of the interceptor which cancels any navigation intent\r\n * and hands control over it to your calling component.\r\n *\r\n * `interceptedPath` is initially `null` and will be set to the target path upon navigation.\r\n * `confirmNavigation` is the callback to be called to stop the interception and navigate to the last path.\r\n * `resetPath` is a callback that resets `interceptedPath` back to `null`.\r\n *\r\n * @returns {Array} [interceptedPath, confirmNavigation, resetPath]\r\n */\r\nexport const useControlledInterceptor = () => {\r\n\tconst [interceptedPath, setInterceptedPath] = React.useState(null);\r\n\r\n\tconst interceptorFunction = React.useMemo(\r\n\t\t() => (currentPath, nextPath) => {\r\n\t\t\tsetInterceptedPath(nextPath);\r\n\t\t\treturn currentPath;\r\n\t\t},\r\n\t\t[setInterceptedPath]\r\n\t);\r\n\r\n\tconst stopInterception = useInterceptor(interceptorFunction);\r\n\r\n\tconst confirmNavigation = React.useMemo(\r\n\t\t() => () => {\r\n\t\t\tstopInterception();\r\n\t\t\tnavigate(interceptedPath);\r\n\t\t},\r\n\t\t[stopInterception, interceptedPath]\r\n\t);\r\n\r\n\tconst resetPath = React.useMemo(\r\n\t\t() => () => setInterceptedPath(null),\r\n\t\t[setInterceptedPath]\r\n\t);\r\n\r\n\treturn [interceptedPath, confirmNavigation, resetPath, stopInterception];\r\n};\r\n"]},"metadata":{},"sourceType":"script"}